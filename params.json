{"name":"Finite State Machine Utilities: Scala","tagline":"Models of finite automata (DFA, NFA) with support of common operations and easily readable creation of concrete machines","body":"FSAUtils\r\n========\r\n\r\nModels of finite automata (DFA, NFA) with support of common operations and easily readable creation of objects.\r\n\r\nThe main goals of this project are:\r\n\r\n* Support of easily readable definitions of finite automata (FA) and regular expressions\r\n* Support of important basic operations on FA\r\n* Adherence to the following coding guidelines aiming to assure correctness:\r\n    * Simple and easily understandable code\r\n    * Mostly adherence to the functional programming paradigm\r\n    * Functional parts of the code (the core) closely follows abstract mathematical definitions of the respective operations\r\n\r\nFeatures supported so far\r\n-------------------------\r\n\r\n* Creation of Deterministic Finite Automata (DFA)\r\n* Creation of Nondeterministic Finite Automata (NFA)\r\n* Determinization of NFA\r\n* Creation of Regular Expressions (RE)\r\n* Checking for acceptance of a word by an automaton\r\n* Star-Operation for NFA\r\n* Complement for DFA\r\n* Implicit conversion of DFA to NFA\r\n* Pretty-printing toString methods for DFA/NFA\r\n\r\nPlanned Features\r\n----------------\r\n\r\n* Concatenation, Star, Union, Intersection, Complement for DFA/NFA\r\n* Minimization of DFA\r\n* Determination of the language (RE) of a DFA/NFA\r\n* Checking for equivalence of DFA/NFA/RE\r\n\r\nExamples\r\n--------\r\n\r\nPlease consider the files Main.scala and FSA_DSL_Test.scala to see some\r\nworking applied examples.\r\n\r\n#### Creation of a DFA\r\n\r\n````\r\nval myDFA =\r\n    dfa ('Z, 'S, 'q0, 'd, 'A) where\r\n\t    'Z  ==> Set('a, 'b)   and\r\n\t    'S  ==> Set(0, 1)     and\r\n\t    'q0 ==> 0             and\r\n\t    'A  ==> Set(0)        and\r\n\t    'd  ==> Delta(\r\n              (0, 'a) -> 0,\r\n              (0, 'b) -> 1,\r\n              (1, 'a) -> 0,\r\n              (1, 'b) -> 1\r\n        )|\r\n\r\nprint(\"DFA accepts aaab: \")\r\nprintln(myDFA accepts \"aaab\")\r\n````\r\n\r\n#### Creation of an NFA\r\n\r\n````\r\nval myNFA =\r\n    nfa ('Z, 'S, 'q0, 'd, 'A) where\r\n        'Z  ==> Set('a, 'b)   and\r\n        'S  ==> Set(0, 1)     and\r\n        'q0 ==> 0             and\r\n        'A  ==> Set(1)        and\r\n        'd  ==> Delta(\r\n              (0, 'a) -> Set(0, 1),\r\n              (0, 'b) -> Set(0)\r\n        )||\r\n\r\nprint(\"NFA accepts aaab: \")\r\nprintln(myNFA accepts \"aaab\")\r\n````\r\n\r\n#### Star Operation for NFA\r\n\r\n````\r\nprintln((myNFA*) accepts \"aaabaaab\")\r\n````\r\n\r\n#### Determinization for NFA\r\n\r\n````\r\nprintln((myNFA toDFA) accepts \"aaab\")\r\n````\r\n\r\n#### Complement for DFA\r\n\r\n````\r\nprintln((!myDFA) accepts \"aaab\")\r\n````\r\n\r\n#### Pretty Printing\r\n\r\n`println(myNFA toDFA)` yields:\r\n\r\n```` \r\nDFA (Z,S,q0,d,A) with\r\n|    Z = {a,b}\r\n|    S = {{},{0},{1},{0,1}}\r\n|    q0 = {0}\r\n|    A = {{1},{0,1}}\r\n|    d = {\r\n|        ({},a) => {},\r\n|        ({},b) => {},\r\n|        ({0},a) => {0,1},\r\n|        ({0},b) => {0},\r\n|        ({1},a) => {},\r\n|        ({1},b) => {},\r\n|        ({0,1},a) => {0,1},\r\n|        ({0,1},b) => {0}\r\n|    }\r\n````\r\n\r\n#### Creation of RE\r\n\r\n````\r\ndef myRegExp = (('a*) + ('b & ('b*) & 'a))* : RE\r\n````\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}